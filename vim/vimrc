" Silnar Vim Configuration
" useful links:
" - Favorite vim plugins & scripts: http://stackoverflow.com/questions/21725/favorite-gvim-plugins-scripts
" - http://amix.dk/vim/vimrc.html
" - http://statico.github.io/vim.html
" - http://www.vimninjas.com/2012/08/26/10-vim-color-schemes-you-need-to-own/
" - https://github.com/haya14busa/dotfiles/blob/master/.vimrc

" Startup {{{
" Note: Skip initialization for vim-tiny or vim-small.
if !1 | finish | endif

" Echo startup time on starup
" if has('vim_starting') && has('reltime')
"   " Shell: vim --startuptime filename -q; vim filename
"   " Shell: vim --cmd 'profile start profile.txt' --cmd 'profile file $HOME/.vimrc' +q && vim profile.txt
"
"   let s:startuptime = reltime()
"   autocmd VimEnter * let s:startuptime = reltime(s:startuptime) | redraw
"   \ | echomsg 'startuptime: ' . reltimestr(s:startuptime)
" endif

"}}}

" NeoBundle {{{
if ! isdirectory(expand('~/.vim/bundle'))
  echon "Installing neobundle.vim..."
  silent call mkdir(expand('~/.vim/bundle'), 'p')
  silent !git clone https://github.com/Shougo/neobundle.vim $HOME/.vim/bundle/neobundle.vim
  echo "done."
  if v:shell_error
    echoerr "neobundle.vim installation has failed!"
    finish
  endif
endif

if has('vim_starting')
  set nocompatible
  set runtimepath& runtimepath+=~/.vim/bundle/neobundle.vim/
endif

function! s:load_bundles() "{{{
  " Let NeoBundle manage NeoBundle
  NeoBundleFetch 'Shougo/neobundle.vim'

  NeoBundle 'Shougo/vimproc', {
  \  'build' : {
  \    'windows' : 'make -f make_mingw32.mak',
  \    'cygwin'  : 'make -f make_cygwin.mak',
  \    'mac'     : 'make -f make_mac.mak',
  \    'unix'    : 'make -f make_unix.mak',
  \  },
  \}

  NeoBundle 'morhetz/gruvbox'
  " NeoBundle 'zeis/vim-kolor'
  " NeoBundle 'Zenburn'
  " NeoBundle 'synic.vim'
  NeoBundle 'github-theme'
  " NeoBundle 'altercation/vim-colors-solarized'
  " NeoBundle 'twilight'
  " NeoBundle 'Wombat'
  " NeoBundle 'noctu.vim'
  " NeoBundle 'vylight'
  " NeoBundle 'vydark'
  NeoBundle 'blerins/flattown'
  NeoBundle 'vim-scripts/less.vim'
  NeoBundle 'vim-scripts/strange'
  " NeoBundle 'gosukiwi/vim-atom-dark'
  " NeoBundle 'lsdr/monokai'
  NeoBundle 'cocopon/iceberg.vim'

  NeoBundle 'tpope/vim-unimpaired'
  NeoBundle 'tpope/vim-surround'
  NeoBundle 'tommcdo/vim-exchange'
  NeoBundleLazy 'sjl/gundo.vim'
  NeoBundle 'godlygeek/tabular'

  NeoBundleLazy 'Shougo/vimfiler.vim'
  NeoBundle 'Shougo/unite.vim'
  NeoBundle 'Shougo/unite-outline'
  if has("lua") && v:version >= 703
    NeoBundleLazy 'Shougo/neocomplete.vim'
  else
    NeoBundleLazy 'Shougo/neocomplcache.vim'
  endif
  NeoBundleLazy 'Shougo/neosnippet.vim', {
  \  'depends' : [
  \    'Shougo/neosnippet-snippets',
  \    'Shougo/context_filetype.vim',
  \  ],
  \  'insert' : 1,
  \  'filetypes' : 'snippet',
  \  'unite_sources' : [
  \    'neosnippet',
  \    'neosnippet/user',
  \    'neosnippet/runtime',
  \  ],
  \}
  " 'honza/vim-snippets',

  NeoBundleLazy 'Rip-Rip/clang_complete'
  NeoBundleLazy 'fatih/vim-go'

  NeoBundle 'Syntastic'
  NeoBundle 'tComment'
  NeoBundle 'tpope/vim-fugitive'

  NeoBundleLazy 'taskpaper.vim'
  NeoBundleLazy 'bitc/vim-hdevtools'
  NeoBundleLazy 'ujihisa/neco-ghc'
  NeoBundleLazy 'bitc/lushtags'
  NeoBundleLazy 'idris-hackers/idris-vim'
endfunction "}}}

call neobundle#begin(expand('~/.vim/bundle/'))

if neobundle#has_fresh_cache()
  NeoBundleLoadCache
else
  call s:load_bundles()
  NeoBundleSaveCache
endif

call neobundle#end()

filetype plugin indent on

au FileType haskell NeoBundleSource vim-hdevtools neco-ghc lushtags
au FileType taskpaper NeoBundleSource taskpaper.vim
" }}}

" Vim options {{{
" Syntax highlighting
syntax on

" Code completion
set omnifunc=syntaxcomplete#Complete

" Gui options
set guioptions=

if has("gui_running")
  if has("gui_macvim")
    set guifont=Monaco:h14
  else
    set guifont=Bitstream\ Vera\ Sans\ Mono\ 14
  endif
endif

" Enable mouse support on terminals
if has("mouse")
  set mouse=a
endif

" Assume fast terminal connection
set ttyfast

" Colorscheme
colorscheme gruvbox
set background=dark

" Highlight current line
set cursorline

" Show line numbers
set number

" Show file position
set ruler

" Show matching brackets
set showmatch
set matchtime=2

" Don't redraw while executing macros (good performance config)
set lazyredraw

" Buffers
set autowrite
set hid

" Windows
set noequalalways
set laststatus=2

" Tabs
set tabstop=2
set softtabstop=2
set shiftwidth=2
set expandtab

" Searching
set ignorecase
set smartcase
set incsearch
" set hlsearch

" Wild menu
set wildmenu
set wildmode=longest:full,full
set wildignore=*.o,*~,*.pyc

" Configure backspace so it acts as it should act
set backspace=eol,start,indent
set whichwrap+=<,>,h,l

" Persistence
set viminfo+=!

" Swap files
let s:swapDir = $HOME . "/.vimswap"
if !isdirectory(s:swapDir)
  call mkdir(s:swapDir)
endif

set directory-=.
let &directory = s:swapDir . '//,' . &directory

" Invisible symbols
set listchars=tab:▸\ ,eol:¬

" Statusline
set statusline=%n\ %f%<
set statusline+=\ %m%r%h%w%q
set statusline+=%=
set statusline+=%{fugitive#statusline()}
set statusline+=\ %y
set statusline+=[%{strlen(&fenc)?&fenc:&enc}]
set statusline+=[row:%l\ col:%v]

" Folding
" http://dhruvasagar.com/2013/03/28/vim-better-foldtext
function! NeatFoldText()
  let line = ' ' . substitute(getline(v:foldstart), '^\s*"\?\s*\|\s*"\?\s*{{' . '{\d*\s*', '', 'g') . ' '
  let lines_count = v:foldend - v:foldstart + 1
  let lines_count_text = '| ' . printf("%10s", lines_count . ' lines') . ' |'
  let foldchar = matchstr(&fillchars, 'fold:\zs.')
  let foldtextstart = strpart('+' . repeat(foldchar, v:foldlevel*2) . line, 0, (winwidth(0)*2)/3)
  let foldtextend = lines_count_text . repeat(foldchar, 8)
  let foldtextlength = strlen(substitute(foldtextstart . foldtextend, '.', 'x', 'g')) + &foldcolumn
  return foldtextstart . repeat(foldchar, winwidth(0)-foldtextlength) . foldtextend
endfunction

set foldtext=NeatFoldText()
" }}}

" Global mappings {{{
" Unite
nnoremap    [unite]   <Nop>
nmap    <Leader>f [unite]

nnoremap <silent> [unite]f :<C-u>Unite -default-action=lcd bookmark<CR>
nnoremap <silent> [unite]b :<C-u>Unite buffer<CR>
nnoremap <silent> [unite]m :<C-u>Unite file_mru<CR>
nnoremap <silent> [unite]p :<C-u>Unite -start-insert file_rec/async:!<CR>
nnoremap <silent> [unite]r :<C-u>Unite -start-insert file_rec/async<CR>
nnoremap <silent> [unite]g :<C-u>Unite grep:.<CR>

" Explore
nmap <Leader>e :VimFilerExplorer<CR>

" Outline
nmap <Leader>o :Unite outline<CR>

" Run Gundo
nmap <Leader>u :GundoToggle<CR>

" Open new tab
nmap <Leader>t :tabnew<CR>

" Write file
nmap <C-S> :w<CR>
nmap <Leader>w :w<CR>

" Hide search highlight
nmap <Leader>h :set hlsearch!<CR>

" Show invisibles
nmap <leader>l :set list!<CR>

" Set background
nmap <Leader>bd :set background=dark<CR>
nmap <Leader>bl :set background=light<CR>

" Edit preferences
nmap <Leader>. :edit ~/.vimrc<CR>
nmap <Leader>> :source ~/.vimrc<CR>

" Substitute word under cursor
nmap <Leader>r :%s/\<<C-r><C-w>\>//gc<Left><Left><Left>
vnoremap <Leader>r "hy:%s/<C-r>h//gc<left><left><left>

" " Item info
" au FileType haskell nmap <Leader>i :HdevtoolsInfo<CR>
" au FileType haskell nmap <Leader>t :HdevtoolsType<CR>
" au FileType haskell nmap <Leader>c :HdevtoolsClear<CR>

" }}}

" Commandline mappings {{{
cnoremap <C-a>  <Home>
cnoremap <C-b>  <Left>
cnoremap <C-f>  <Right>
" cnoremap <C-d>  <Delete>
cnoremap <M-b>  <S-Left>
cnoremap <M-f>  <S-Right>
" cnoremap <M-d>  <S-right><Delete>
" cnoremap <Esc>b <S-Left>
" cnoremap <Esc>f <S-Right>
" cnoremap <Esc>d <S-right><Delete>
" cnoremap <C-g>  <C-c>
" }}}

" Filetype & Autocommand {{{
" Tabs
autocmd Filetype haskell setlocal ts=2 sts=2 sw=2 et ai
autocmd Filetype taskpaper setlocal ts=2 sts=2 sw=2 ai

" Remove trailing whitespaces on write
autocmd BufWritePre * :%s/\s\+$//e
" }}}

" Plugin settings {{{

" Shougo/VimFiler {{{
if neobundle#tap('vimfiler.vim')
    " Config {{{
    call neobundle#config({
        \   'autoload' : {
        \    'commands' : [
        \       { 'name' : 'VimFiler',
        \         'complete' : 'customlist,vimfiler#complete' },
        \       { 'name' : 'VimFilerTab',
        \         'complete' : 'customlist,vimfiler#complete' },
        \       { 'name' : 'VimFilerBufferDir',
        \         'complete' : 'customlist,vimfiler#complete' },
        \       { 'name' : 'VimFilerExplorer',
        \         'complete' : 'customlist,vimfiler#complete' },
        \       { 'name' : 'Edit',
        \         'complete' : 'customlist,vimfiler#complete' },
        \       { 'name' : 'Write',
        \         'complete' : 'customlist,vimfiler#complete' },
        \       'Read', 'Source'],
        \    'mappings' : '<Plug>(vimfiler_',
        \    'explorer' : 1,
        \   }
        \ })
    " }}}
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
      let g:vimfiler_as_default_explorer = 1

      " Enable file operation commands.
      " let g:vimfiler_safe_mode_by_default = 0

      " Like Textmate icons.
      let g:vimfiler_tree_leaf_icon = ' '
      let g:vimfiler_tree_opened_icon = '▾'
      let g:vimfiler_tree_closed_icon = '▸'
      let g:vimfiler_file_icon = '-'
      let g:vimfiler_marked_file_icon = '*'
    endfunction "}}}

  call neobundle#untap()
endif

" autocmd FileType vimfiler nmap <buffer><silent> <Enter>
"       \ :<C-u>execute "normal " . vimfiler#mappings#smart_cursor_map(
"       \  "\<Plug>(vimfiler_cd_file)",
"       \  "\<Plug>(vimfiler_edit_file)")<CR>
"
" autocmd FileType vimfiler nmap <buffer><silent> <2-LeftMouse> :call <SID>vimfiler_on_double_click()<CR>
" function! s:vimfiler_on_double_click() "{{{
"   let context = vimfiler#get_context()
"
"   if context.explorer
"     let mapping = vimfiler#mappings#smart_cursor_map(
"           \ "\<Plug>(vimfiler_expand_tree)",
"           \ "\<Plug>(vimfiler_edit_file)"
"           \ )
"   else
"     let mapping = vimfiler#mappings#smart_cursor_map(
"           \ "\<Plug>(vimfiler_cd_file)",
"           \ "\<Plug>(vimfiler_edit_file)"
"           \ )
"   endif
"
"   execute "normal " . mapping
" endfunction"}}}
"
" let s:vimfilerexplorer = {
"       \ 'description' : 'open vimfiler explorer here',
"       \ }
" function! s:vimfilerexplorer.func(candidate) "{{{
"   if !exists(':VimFilerExplorer')
"     echo 'vimfiler is not installed.'
"     return
"   endif
"
"   if !s:check_is_directory(a:candidate.action__directory)
"     return
"   endif
"
"   execute 'VimFilerExplorer' escape(a:candidate.action__directory, '\ ')
"
"   if has_key(a:candidate, 'action__path')
"         \ && a:candidate.action__directory !=# a:candidate.action__path
"     " Move cursor.
"     call vimfiler#mappings#search_cursor(a:candidate.action__path)
"     call s:move_vimfiler_cursor(a:candidate)
"   endif
" endfunction"}}}
"
" function! s:move_vimfiler_cursor(candidate) "{{{
"   if &filetype !=# 'vimfiler'
"     return
"   endif
"
"   if has_key(a:candidate, 'action__path')
"         \ && a:candidate.action__directory !=# a:candidate.action__path
"     " Move cursor.
"     call vimfiler#mappings#search_cursor(a:candidate.action__path)
"   endif
" endfunction"}}}
"
" function! s:check_is_directory(directory) "{{{
"   if !isdirectory(a:directory)
"     let yesno = input(printf(
"           \ 'Directory path "%s" is not exists. Create? : ', a:directory))
"     redraw
"     if yesno !~ '^y\%[es]$'
"       echo 'Canceled.'
"       return 0
"     endif
"
"     call mkdir(a:directory, 'p')
"   endif
"
"   return 1
" endfunction
" "}}}
"
" call unite#custom#action('cdable', 'vimfilerexplorer', s:vimfilerexplorer)
" }}}

" Shougo/neosnippet.vim "{{{
if neobundle#tap('neosnippet.vim')
    function! neobundle#tapped.hooks.on_source(bundle) "{{{
        " For snippet_complete marker.
        if has('conceal')
            set conceallevel=2 concealcursor=i
        endif

        " Enable snipMate compatibility feature.
        " let g:neosnippet#enable_snipmate_compatibility = 1

        " Remove snippets marker automatically
        " Autocmd InsertLeave * :NeoSnippetClearMarkers

        " Prioratise snippet
        " call neocomplete#custom#source('neosnippet', 'rank', 400)

        " snoremap <Esc> <Esc>:NeoSnippetClearMarkers<CR>
    endfunction "}}}

    " Plugin key-mappings.
    imap <C-k>     <Plug>(neosnippet_expand_or_jump)
    smap <C-k>     <Plug>(neosnippet_expand_or_jump)
    xmap <C-k>     <Plug>(neosnippet_expand_target)

    " SuperTab like snippets behavior.
    imap <expr><TAB> neosnippet#expandable_or_jumpable() ?
          \ "\<Plug>(neosnippet_expand_or_jump)"
          \: pumvisible() ? "\<C-n>" : "\<TAB>"
    smap <expr><TAB> neosnippet#expandable_or_jumpable() ?
          \ "\<Plug>(neosnippet_expand_or_jump)"
          \: "\<TAB>"

  call neobundle#untap()
endif
" }}}

" Shougo/neocomplete.vim"{{{
if neobundle#tap('neocomplete.vim')
    call neobundle#config({
        \   'depends' : ['Shougo/neosnippet'],
        \   'autoload' : {
        \     'insert' : 1,
        \   }
        \ })
    function! neobundle#tapped.hooks.on_source(bundle)
        " Use smartcase.
        let g:neocomplete#enable_smart_case = 1
        let g:neocomplete#enable_camel_case = 1
        let g:neocomplete#enable_underbar_completion = 1

        " Use fuzzy completion.
        let g:neocomplete#enable_fuzzy_completion = 1

        " Set minimum syntax keyword length.
        let g:neocomplete#sources#syntax#min_keyword_length = 3
        " Set auto completion length.
        let g:neocomplete#auto_completion_start_length = 2
        " Set manual completion length.
        let g:neocomplete#manual_completion_start_length = 0
        " Set minimum keyword length.
        let g:neocomplete#min_keyword_length = 3

        " Set neosnippet competion length.
        call neocomplete#custom#source('neosnippet', 'min_pattern_length', 1)

        let g:neocomplete#disable_auto_select_buffer_name_pattern =
                    \ '\[Command Line\]'

        " Enable omni completion.
        " autocmd css setlocal omnifunc=csscomplete#CompleteCSS
        " autocmd html,markdown setlocal omnifunc=htmlcomplete#CompleteTags
        " autocmd javascript setlocal omnifunc=javascriptcomplete#CompleteJS
        " autocmd javascript setlocal omnifunc=tern#Complete
        " autocmd coffee setlocal omnifunc=javascriptcomplete#CompleteJS
        " autocmd xml setlocal omnifunc=xmlcomplete#CompleteTags
        " autocmd python setlocal omnifunc=jedi#completions
    endfunction

    " Use neocomplete.
    let g:neocomplete#enable_at_startup = 1

    " Plugin key-mappings.
    " inoremap <expr><C-g>     neocomplete#undo_completion()
    " inoremap <expr><C-l>     neocomplete#complete_common_string()

    " <Tab>: completion
    " inoremap <expr><Tab> pumvisible() ? "\<C-n>" : "\<Tab>"
    " inoremap <expr><S-Tab> pumvisible() ? "\<C-p>" : "\<S-Tab>"

    " <C-f>, <C-b>: page move.
    " inoremap <expr><C-f>  pumvisible() ? "\<PageDown>" : "\<Right>"
    " inoremap <expr><C-b>  pumvisible() ? "\<PageUp>"   : "\<Left>"
    " <C-y>: paste.
    " inoremap <expr><C-y>  pumvisible() ? neocomplete#close_popup() :  "\<C-r>\""
    " <C-e>: close popup.
    " inoremap <expr><C-e>  pumvisible() ? neocomplete#cancel_popup() : "\<End>"

    call neobundle#untap()
endif
"}}}

" Shougo/neocomplcache.vim"{{{
if neobundle#tap('neocomplcache.vim')
    call neobundle#config({
        \   'autoload' : {
        \     'insert' : 1,
        \   }
        \ })
    function! neobundle#tapped.hooks.on_source(bundle)
        let g:neocomplcache_enable_smart_case = 1
    endfunction
    call neobundle#untap()
endif
"}}}

" TComment {{{
if neobundle#tap('tComment')
  let g:tcomment#replacements_c = {
            \     '/*': '#<{(|',
            \     '*/': '|)}>#',
            \ }
  let g:tcommentLineC = {
            \ 'commentstring': '// %s',
            \ 'replacements': g:tcomment#replacements_c
            \ }
  call neobundle#untap()
endif
" }}}

" sjl/gundo.vim" {{{
if neobundle#tap('gundo.vim')
  call neobundle#config({
    \ "autoload": {
    \   "commands": ['GundoToggle'],
    \   }
    \ })
  call neobundle#untap()
endif
"}}}

" Rip-Rip/clang_complete {{{
if neobundle#tap('clang_complete')
  call neobundle#config({
    \ "autoload": {
    \   "filetypes": ['c', 'cpp', 'objc', 'objcpp'],
    \   }
    \ })

  if !exists('g:neocomplete#force_omni_input_patterns')
    let g:neocomplete#force_omni_input_patterns = {}
  endif
  let g:neocomplete#force_overwrite_completefunc = 1
  let g:neocomplete#force_omni_input_patterns.c =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\w*'
  let g:neocomplete#force_omni_input_patterns.cpp =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
  let g:neocomplete#force_omni_input_patterns.objc =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\w*'
  let g:neocomplete#force_omni_input_patterns.objcpp =
        \ '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*'
  let g:clang_complete_auto = 0
  let g:clang_auto_select = 0
  "let g:clang_use_library = 1

  call neobundle#untap()
endif
" }}}

" fatih/vim-go {{{
if neobundle#tap('vim-go')
  call neobundle#config({
    \ "autoload": {
    \   "filetypes": ['go'],
    \   }
    \ })
  call neobundle#untap()
endif
"}}}

" idris-hackers/idris-vim {{{
if neobundle#tap('idris-vim')
  call neobundle#config({
    \ "autoload": {
    \   "filetypes": ['idris'],
    \   }
    \ })
  call neobundle#untap()
endif
" }}}

" Neco-GHC {{{
let g:necoghc_enable_detailed_browse = 1
" }}}

" }}}

" Finally {{{
NeoBundleCheck

if !has('vim_starting')
  call neobundle#call_hook('on_source')
endif

set secure
"}}}

" vim:foldmethod=marker
